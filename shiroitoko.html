<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>タワー積みゲーム</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* スクロールバー非表示 */
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            border: 2px solid #333;
            background-color: #fff;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

    <script>
        // Matter.jsのエイリアスを設定（コードを短くするため）
        var Engine = Matter.Engine,
            Render = Matter.Render,
            Runner = Matter.Runner,
            Bodies = Matter.Bodies,
            Composite = Matter.Composite,
            MouseConstraint = Matter.MouseConstraint,
            Mouse = Matter.Mouse,
            Events = Matter.Events;

        // 1. エンジンとレンダラーの設定
        var width = 600;
        var height = 800;

        var engine = Engine.create();
        var render = Render.create({
            element: document.body,
            engine: engine,
            options: {
                width: width,
                height: height,
                wireframes: false, // ワイヤーフレーム表示を無効にして色を付ける
                background: '#fafafa'
            }
        });

        // 2. 地面と壁の作成
        var ground = Bodies.rectangle(width / 2, height, width, 50, { 
            isStatic: true, // 静止オブジェクト（動かない）
            render: { fillStyle: '#666' }
        });

        // 左右の壁
        var wallL = Bodies.rectangle(0, height / 2, 50, height, { isStatic: true, render: { fillStyle: '#666' } });
        var wallR = Bodies.rectangle(width, height / 2, 50, height, { isStatic: true, render: { fillStyle: '#666' } });
        
        // 3. 全てのオブジェクトをワールドに追加
        Composite.add(engine.world, [ground, wallL, wallR]);

        // 4. マウス操作の設定（既存のブロックを掴んで動かせるようにする）
        var mouse = Mouse.create(render.canvas),
            mouseConstraint = MouseConstraint.create(engine, {
                mouse: mouse,
                constraint: {
                    stiffness: 0.2,
                    render: {
                        visible: false
                    }
                }
            });

        Composite.add(engine.world, mouseConstraint);
        render.mouse = mouse; // レンダラーとマウスを同期

        // 5. 実行処理
        Render.run(render);
        var runner = Runner.create();
        Runner.run(runner, engine);

        // --- ゲームの主要ロジック ---

        // 新しいブロックを生成する関数
        function createRandomBlock(x, y) {
            // ランダムなサイズ
            var sizeW = Math.random() * 50 + 30; // 30〜80
            var sizeH = Math.random() * 50 + 30; // 30〜80
            
            // ランダムな色
            var color = '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');

            // ブロックの作成
            var block = Bodies.rectangle(x, y, sizeW, sizeH, {
                restitution: 0.2, // 反発係数（跳ねにくさ）
                density: 0.001,   // 密度
                friction: 0.8,    // 摩擦
                render: {
                    fillStyle: color,
                    strokeStyle: 'black',
                    lineWidth: 1
                }
            });

            Composite.add(engine.world, block);
        }

        // 6. クリックイベントでブロックを生成
        Events.on(render, 'click', function(event) {
            var mousePosition = event.mouse.position;
            
            // マウスのX座標、画面上部少し下のY座標からブロックを落とす
            createRandomBlock(mousePosition.x, 50); 
        });

        // 7. キー操作でブロックを生成（タワー積みのコントロール用）
        // ※この段階ではマウスで生成位置を選ぶだけですが、キー操作でブロックを制御する実装も可能です。
        // 例：キーを押したら画面上部中央からブロックを落とす
        document.addEventListener('keydown', function(event) {
            if (event.code === 'Space') {
                createRandomBlock(width / 2, 50); // スペースキーで中央から落とす
            }
        });

    </script>
</body>
</html>
